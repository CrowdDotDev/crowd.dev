import {
  ALL_PLATFORM_TYPES,
  ActivityDisplayVariant,
  MemberAttributeType,
  OpenSearchIndex,
  PlatformType,
  SyncStatus,
  OrganizationSource,
  FeatureFlag,
  PageData,
  SegmentData,
  SegmentProjectGroupNestedData,
  SegmentProjectNestedData,
} from '@crowd/types'
import lodash, { chunk } from 'lodash'
import moment from 'moment'
import Sequelize, { QueryTypes } from 'sequelize'

import { Error400, Error404 } from '@crowd/common'
import { FieldTranslatorFactory, OpensearchQueryParser } from '@crowd/opensearch'
import { ActivityDisplayService } from '@crowd/integrations'
import { KUBE_MODE, SERVICE } from '@/conf'
import { ServiceType } from '../../conf/configTypes'
import isFeatureEnabled from '../../feature-flags/isFeatureEnabled'
import { PlatformIdentities } from '../../serverless/integrations/types/messageTypes'
import {
  MemberSegmentAffiliation,
  MemberSegmentAffiliationJoined,
} from '../../types/memberSegmentAffiliationTypes'
import { AttributeData } from '../attributes/attribute'
import SequelizeFilterUtils from '../utils/sequelizeFilterUtils'
import { IRepositoryOptions } from './IRepositoryOptions'
import AuditLogRepository from './auditLogRepository'
import QueryParser from './filters/queryParser'
import { JsonColumnInfo, QueryOutput } from './filters/queryTypes'
import RawQueryParser from './filters/rawQueryParser'
import MemberSegmentAffiliationRepository from './memberSegmentAffiliationRepository'
import SegmentRepository from './segmentRepository'
import SequelizeRepository from './sequelizeRepository'
import TenantRepository from './tenantRepository'
import {
  IActiveMemberData,
  IActiveMemberFilter,
  IMemberIdentity,
  IMemberMergeSuggestion,
  mapUsernameToIdentities,
} from './types/memberTypes'
import OrganizationRepository from './organizationRepository'
import MemberSyncRemoteRepository from './memberSyncRemoteRepository'
import MemberAffiliationRepository from './memberAffiliationRepository'

const { Op } = Sequelize

const log: boolean = false

interface ActivityAggregates {
  memberId: string
  segmentId: string
  activityCount: number
  activeDaysCount: number
  lastActive: string
  activityTypes: string[]
  activeOn: string[]
  averageSentiment: number
}

class MemberRepository {
  static async create(data, options: IRepositoryOptions, doPopulateRelations = true) {
    if (!data.username) {
      throw new Error('Username not set when creating member!')
    }

    const platforms = Object.keys(data.username) as PlatformType[]
    if (platforms.length === 0) {
      throw new Error('Username object does not have any platforms!')
    }

    data.username = mapUsernameToIdentities(data.username)

    const currentUser = SequelizeRepository.getCurrentUser(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const transaction = SequelizeRepository.getTransaction(options)

    const segment = SequelizeRepository.getStrictlySingleActiveSegment(options)
    const record = await options.database.member.create(
      {
        ...lodash.pick(data, [
          'displayName',
          'attributes',
          'emails',
          'lastEnriched',
          'enrichedBy',
          'contributions',
          'score',
          'reach',
          'joinedAt',
          'manuallyCreated',
          'importHash',
        ]),
        tenantId: tenant.id,
        createdById: currentUser.id,
        updatedById: currentUser.id,
        segmentId: segment.id,
      },
      {
        transaction,
      },
    )

    const username: PlatformIdentities = data.username

    const seq = SequelizeRepository.getSequelize(options)
    const query = `
      insert into "memberIdentities"("memberId", platform, username, "sourceId", "tenantId", "integrationId")
      values(:memberId, :platform, :username, :sourceId, :tenantId, :integrationId);
    `

    for (const platform of Object.keys(username) as PlatformType[]) {
      const identities: any[] = username[platform]
      for (const identity of identities) {
        await seq.query(query, {
          replacements: {
            memberId: record.id,
            platform,
            username: identity.username,
            sourceId: identity.sourceId || null,
            integrationId: identity.integrationId || null,
            tenantId: tenant.id,
          },
          type: QueryTypes.INSERT,
          transaction,
        })
      }
    }

    await MemberRepository.includeMemberToSegments(record.id, options)

    await record.setActivities(data.activities || [], {
      transaction,
    })
    await record.setTags(data.tags || [], {
      transaction,
    })

    await MemberRepository.updateMemberOrganizations(record, data.organizations, true, options)

    await record.setTasks(data.tasks || [], {
      transaction,
    })

    await record.setNotes(data.notes || [], {
      transaction,
    })

    await record.setNoMerge(data.noMerge || [], {
      transaction,
    })
    await record.setToMerge(data.toMerge || [], {
      transaction,
    })

    if (data.affiliations) {
      await this.setAffiliations(record.id, data.affiliations, options)
    }

    await this._createAuditLog(AuditLogRepository.CREATE, record, data, options)

    return this.findById(record.id, options, true, doPopulateRelations)
  }

  static async includeMemberToSegments(memberId: string, options: IRepositoryOptions) {
    const seq = SequelizeRepository.getSequelize(options)

    const transaction = SequelizeRepository.getTransaction(options)

    let bulkInsertMemberSegments = `INSERT INTO "memberSegments" ("memberId","segmentId", "tenantId", "createdAt") VALUES `
    const replacements = {
      memberId,
      tenantId: options.currentTenant.id,
    }

    for (let idx = 0; idx < options.currentSegments.length; idx++) {
      bulkInsertMemberSegments += ` (:memberId, :segmentId${idx}, :tenantId, now()) `

      replacements[`segmentId${idx}`] = options.currentSegments[idx].id

      if (idx !== options.currentSegments.length - 1) {
        bulkInsertMemberSegments += `,`
      }
    }

    bulkInsertMemberSegments += ` ON CONFLICT DO NOTHING`

    await seq.query(bulkInsertMemberSegments, {
      replacements,
      type: QueryTypes.INSERT,
      transaction,
    })
  }

  static async excludeMembersFromSegments(memberIds: string[], options: IRepositoryOptions) {
    const seq = SequelizeRepository.getSequelize(options)

    const transaction = SequelizeRepository.getTransaction(options)

    const bulkDeleteMemberSegments = `DELETE FROM "memberSegments" WHERE "memberId" in (:memberIds) and "segmentId" in (:segmentIds);`

    await seq.query(bulkDeleteMemberSegments, {
      replacements: {
        memberIds,
        segmentIds: SequelizeRepository.getSegmentIds(options),
      },
      type: QueryTypes.DELETE,
      transaction,
    })
  }

  static async findSampleDataMemberIds(options: IRepositoryOptions) {
    const transaction = SequelizeRepository.getTransaction(options)
    const currentTenant = SequelizeRepository.getCurrentTenant(options)
    const sampleMemberIds = await options.database.sequelize.query(
      `select m.id from members m
      where (m.attributes->'sample'->'default')::boolean is true
      and m."tenantId" = :tenantId;
    `,
      {
        replacements: {
          tenantId: currentTenant.id,
        },
        type: QueryTypes.SELECT,
        transaction,
      },
    )

    return sampleMemberIds.map((i) => i.id)
  }

  static async findMembersWithMergeSuggestions(
    { limit = 20, offset = 0 },
    options: IRepositoryOptions,
  ) {
    const currentTenant = SequelizeRepository.getCurrentTenant(options)
    const segmentIds = SequelizeRepository.getSegmentIds(options)

    const mems = await options.database.sequelize.query(
      `SELECT 
        "membersToMerge".id, 
        "membersToMerge"."toMergeId",
        "membersToMerge"."total_count",
        "membersToMerge"."similarity"
      FROM 
      (
        SELECT DISTINCT ON (Greatest(Hashtext(Concat(mem.id, mtm."toMergeId")), Hashtext(Concat(mtm."toMergeId", mem.id)))) 
            mem.id, 
            mtm."toMergeId", 
            mem."joinedAt", 
            COUNT(*) OVER() AS total_count,
            mtm."similarity"
          FROM members mem
          INNER JOIN "memberToMerge" mtm ON mem.id = mtm."memberId"
          JOIN "memberSegments" ms ON ms."memberId" = mem.id
          WHERE mem."tenantId" = :tenantId
            AND ms."segmentId" IN (:segmentIds)
        ) AS "membersToMerge" 
      ORDER BY 
        "membersToMerge"."similarity" DESC 
      LIMIT :limit OFFSET :offset
    `,
      {
        replacements: {
          tenantId: currentTenant.id,
          segmentIds,
          limit,
          offset,
        },
        type: QueryTypes.SELECT,
      },
    )

    if (mems.length > 0) {
      const memberPromises = []
      const toMergePromises = []

      for (const mem of mems) {
        memberPromises.push(MemberRepository.findById(mem.id, options))
        toMergePromises.push(MemberRepository.findById(mem.toMergeId, options))
      }

      const memberResults = await Promise.all(memberPromises)
      const memberToMergeResults = await Promise.all(toMergePromises)

      const result = memberResults.map((i, idx) => ({
        members: [i, memberToMergeResults[idx]],
        similarity: mems[idx].similarity,
      }))
      return { rows: result, count: mems[0].total_count / 2, limit, offset }
    }

    return { rows: [{ members: [], similarity: 0 }], count: 0, limit, offset }
  }

  static async moveIdentitiesBetweenMembers(
    fromMemberId: string,
    toMemberId: string,
    identitiesToMove: any[],
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const query = `
      update "memberIdentities" 
      set 
        "memberId" = :newMemberId
      where 
        "tenantId" = :tenantId and 
        "memberId" = :oldMemberId and 
        platform = :platform and 
        username = :username;
    `

    for (const identity of identitiesToMove) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const [_, count] = await seq.query(query, {
        replacements: {
          tenantId: tenant.id,
          oldMemberId: fromMemberId,
          newMemberId: toMemberId,
          platform: identity.platform,
          username: identity.username,
        },
        type: QueryTypes.UPDATE,
        transaction,
      })

      if (count !== 1) {
        throw new Error('One row should be updated!')
      }
    }
  }

  static async moveActivitiesBetweenMembers(
    fromMemberId: string,
    toMemberId: string,
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const query = `
      update activities set "memberId" = :toMemberId where "memberId" = :fromMemberId and "tenantId" = :tenantId;
    `

    await seq.query(query, {
      replacements: {
        fromMemberId,
        toMemberId,
        tenantId: tenant.id,
      },
      type: QueryTypes.UPDATE,
      transaction,
    })
  }

  static async addToMerge(
    suggestions: IMemberMergeSuggestion[],
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)
    const seq = SequelizeRepository.getSequelize(options)

    // Remove possible duplicates
    suggestions = lodash.uniqWith(suggestions, (a, b) =>
      lodash.isEqual(lodash.sortBy(a.members), lodash.sortBy(b.members)),
    )

    // Process suggestions in chunks of 100 or less
    const suggestionChunks = chunk(suggestions, 100)

    const insertValues = (
      memberId: string,
      toMergeId: string,
      similarity: number | null,
      index: number,
    ) => {
      const idPlaceholder = (key: string) => `${key}${index}`
      return {
        query: `(:${idPlaceholder('memberId')}, :${idPlaceholder('toMergeId')}, :${idPlaceholder(
          'similarity',
        )}, NOW(), NOW())`,
        replacements: {
          [idPlaceholder('memberId')]: memberId,
          [idPlaceholder('toMergeId')]: toMergeId,
          [idPlaceholder('similarity')]: similarity === null ? null : similarity,
        },
      }
    }

    for (const suggestionChunk of suggestionChunks) {
      const placeholders: string[] = []
      let replacements: Record<string, unknown> = {}

      suggestionChunk.forEach((suggestion, index) => {
        const { query, replacements: chunkReplacements } = insertValues(
          suggestion.members[0],
          suggestion.members[1],
          suggestion.similarity,
          index,
        )
        placeholders.push(query)
        replacements = { ...replacements, ...chunkReplacements }
      })

      const query = `
        INSERT INTO "memberToMerge" ("memberId", "toMergeId", "similarity", "createdAt", "updatedAt")
        VALUES ${placeholders.join(', ')} on conflict do nothing;
      `
      try {
        await seq.query(query, {
          replacements,
          type: QueryTypes.INSERT,
          transaction,
        })
      } catch (error) {
        options.log.error('error adding members to merge', error)
        throw error
      }
    }
  }

  static async removeToMerge(id, toMergeId, options: IRepositoryOptions) {
    const transaction = SequelizeRepository.getTransaction(options)

    const returnPlain = false

    const member = await this.findById(id, options, returnPlain)

    const toMergeMember = await this.findById(toMergeId, options, returnPlain)

    await member.removeToMerge(toMergeMember, { transaction })

    return this.findById(id, options)
  }

  static async addNoMerge(id, toMergeId, options: IRepositoryOptions) {
    const transaction = SequelizeRepository.getTransaction(options)

    const returnPlain = false

    const member = await this.findById(id, options, returnPlain)

    const toMergeMember = await this.findById(toMergeId, options, returnPlain)

    await member.addNoMerge(toMergeMember, { transaction })

    return this.findById(id, options)
  }

  static async removeNoMerge(id, toMergeId, options: IRepositoryOptions) {
    const transaction = SequelizeRepository.getTransaction(options)

    const returnPlain = false

    const member = await this.findById(id, options, returnPlain)

    const toMergeMember = await this.findById(toMergeId, options, returnPlain)

    await member.removeNoMerge(toMergeMember, { transaction })

    return this.findById(id, options)
  }

  static async memberExists(
    username,
    platform,
    options: IRepositoryOptions,
    doPopulateRelations = true,
  ) {
    const transaction = SequelizeRepository.getTransaction(options)

    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    const seq = SequelizeRepository.getSequelize(options)

    const usernames: string[] = []
    if (typeof username === 'string') {
      usernames.push(username)
    } else if (Array.isArray(username)) {
      usernames.push(...username)
    } else {
      throw new Error(
        'Unknown username format! Allowed formats are string or string[]. For example: "username" or ["username1", "username2"]',
      )
    }

    // first find the id - we don't need the other bloat
    const results = await seq.query(
      `
    select mi."memberId"
    from "memberIdentities" mi
    where mi."tenantId" = :tenantId and
          mi.platform = :platform and
          mi.username in (:usernames) and
          exists (select 1 from "memberSegments" ms where ms."memberId" = mi."memberId")
  `,
      {
        type: Sequelize.QueryTypes.SELECT,
        replacements: {
          tenantId: currentTenant.id,
          platform,
          usernames,
        },
        transaction,
      },
    )

    const ids = results.map((r: any) => r.memberId)

    if (ids.length === 0) {
      return null
    }

    if (doPopulateRelations) {
      return this.findById(ids[0], options)
    }

    // the if needed actualy query the db for the rest by primary/foreign key which is much faster
    const records = await seq.query(
      `
      with segment_ids as (
        select "memberId", array_agg("segmentId") as "segmentIds" from
        "memberSegments"
        where "memberId" = :memberId
        group by "memberId"
      ),
      identities as (select mi."memberId",
                            array_agg(distinct mi.platform)             as identities,
                            jsonb_object_agg(mi.platform, mi.usernames) as username
                      from (select "memberId",
                                  platform,
                                  array_agg(username) as usernames
                            from (select "memberId",
                                        platform,
                                        username,
                                        "createdAt",
                                        row_number() over (partition by "memberId", platform order by "createdAt" desc) =
                                        1 as is_latest
                                  from "memberIdentities" where "memberId" = :memberId) sub
                            group by "memberId", platform) mi
                      group by mi."memberId"),
        member_organizations as (
          select
            "memberId",
            JSONB_AGG(
                DISTINCT JSONB_BUILD_OBJECT(
                  'id', "organizationId",
                  'memberOrganizations',
                  JSONB_BUILD_OBJECT(
                    'memberId', "memberId",
                    'organizationId', "organizationId",
                    'dateStart', "dateStart",
                    'dateEnd', "dateEnd",
                    'createdAt', "createdAt",
                    'updatedAt', "updatedAt",
                    'title', title,
                    'source', source
                  )
                )
            ) AS orgs
          from "memberOrganizations"
          where "memberId" = :memberId
            and "deletedAt" is null
          group by "memberId"
        )
        select m."id",
              m."displayName",
              m."attributes",
              m."emails",
              m."score",
              m."lastEnriched",
              m."enrichedBy",
              m."contributions",
              m."reach",
              m."joinedAt",
              m."importHash",
              m."createdAt",
              m."updatedAt",
              m."deletedAt",
              m."tenantId",
              m."createdById",
              m."updatedById",
              i.username,
              si."segmentIds" as segments,
              coalesce(mo.orgs, '[]'::JSONB) as "organizations"
        from members m
                inner join identities i on i."memberId" = m.id
                inner join segment_ids si on si."memberId" = m.id
                left join member_organizations mo on mo."memberId" = m.id
        where m.id = :memberId;`,
      {
        type: Sequelize.QueryTypes.SELECT,
        replacements: {
          memberId: ids[0],
        },
        transaction,
      },
    )

    if (records.length !== 1) {
      throw new Error('Invalid number of records found!')
    }

    return records[0]
  }

  static async update(id, data, options: IRepositoryOptions, doPopulateRelations = true) {
    const currentUser = SequelizeRepository.getCurrentUser(options)

    const transaction = SequelizeRepository.getTransaction(options)

    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    let record = await options.database.member.findOne({
      where: {
        id,
        tenantId: currentTenant.id,
      },
      transaction,
    })

    if (!record) {
      throw new Error404()
    }

    // exclude syncRemote attributes, since these are populated from memberSyncRemote table
    if (data.attributes?.syncRemote) {
      delete data.attributes.syncRemote
    }

    record = await record.update(
      {
        ...lodash.pick(data, [
          'displayName',
          'attributes',
          'emails',
          'lastEnriched',
          'enrichedBy',
          'contributions',
          'score',
          'reach',
          'joinedAt',
          'importHash',
        ]),

        updatedById: currentUser.id,
      },
      {
        transaction,
      },
    )

    if (data.activities) {
      await record.setActivities(data.activities || [], {
        transaction,
      })
    }

    if (data.tags) {
      await record.setTags(data.tags || [], {
        transaction,
      })
    }

    if (data.tasks) {
      await record.setTasks(data.tasks || [], {
        transaction,
      })
    }

    if (data.notes) {
      await record.setNotes(data.notes || [], {
        transaction,
      })
    }

    await MemberRepository.updateMemberOrganizations(
      record,
      data.organizations,
      data.organizationsReplace,
      options,
    )

    if (data.noMerge) {
      await record.setNoMerge(data.noMerge || [], {
        transaction,
      })
    }

    if (data.toMerge) {
      await record.setToMerge(data.toMerge || [], {
        transaction,
      })
    }

    if (data.affiliations) {
      await MemberRepository.setAffiliations(id, data.affiliations, options)
    }

    if (options.currentSegments && options.currentSegments.length > 0) {
      await MemberRepository.includeMemberToSegments(record.id, options)
    }

    const seq = SequelizeRepository.getSequelize(options)

    if (data.username) {
      data.username = mapUsernameToIdentities(data.username)

      const platforms = Object.keys(data.username) as PlatformType[]
      if (platforms.length > 0) {
        const query = `
          insert into "memberIdentities"("memberId", platform, username, "sourceId", "tenantId", "integrationId")
          values (:memberId, :platform, :username, :sourceId, :tenantId, :integrationId);
          `
        const deleteQuery = `
          delete from "memberIdentities"
          where ("memberId", "tenantId", "platform", "username") in
                (select mi."memberId", mi."tenantId", mi."platform", mi."username"
                from "memberIdentities" mi
                          join (select :memberId::uuid            as memberid,
                                      :tenantId::uuid            as tenantid,
                                      unnest(:platforms::text[]) as platform,
                                      unnest(:usernames::text[]) as username) as combinations
                              on mi."memberId" = combinations.memberid
                                  and mi."tenantId" = combinations.tenantid
                                  and mi."platform" = combinations.platform
                                  and mi."username" = combinations.username);`

        const platformsToDelete: string[] = []
        const usernamesToDelete: string[] = []

        for (const platform of platforms) {
          const identities = data.username[platform]

          for (const identity of identities) {
            if (identity.delete) {
              platformsToDelete.push(identity.platform)
              usernamesToDelete.push(identity.username)
            } else {
              await seq.query(query, {
                replacements: {
                  memberId: record.id,
                  platform,
                  username: identity.username,
                  sourceId: identity.sourceId || null,
                  integrationId: identity.integrationId || null,
                  tenantId: currentTenant.id,
                },
                type: QueryTypes.INSERT,
                transaction,
              })
            }
          }
        }

        if (platformsToDelete.length > 0) {
          await seq.query(deleteQuery, {
            replacements: {
              tenantId: currentTenant.id,
              memberId: record.id,
              platforms: `{${platformsToDelete.join(',')}}`,
              usernames: `{${usernamesToDelete.join(',')}}`,
            },
            type: QueryTypes.DELETE,
            transaction,
          })
        }
      }
    }

    await this._createAuditLog(AuditLogRepository.UPDATE, record, data, options)

    return this.findById(record.id, options, true, doPopulateRelations)
  }

  static async destroy(id, options: IRepositoryOptions, force = false) {
    const transaction = SequelizeRepository.getTransaction(options)

    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    await MemberRepository.excludeMembersFromSegments([id], { ...options, transaction })
    const member = await this.findById(id, options, true, false)

    // if member doesn't belong to any other segment anymore, remove it
    if (member.segments.length === 0) {
      const record = await options.database.member.findOne({
        where: {
          id,
          tenantId: currentTenant.id,
        },
        transaction,
      })

      if (!record) {
        throw new Error404()
      }

      await record.destroy({
        force,
        transaction,
      })
      await this._createAuditLog(AuditLogRepository.DELETE, record, record, options)
    }
  }

  static async destroyBulk(ids, options: IRepositoryOptions, force = false) {
    const transaction = SequelizeRepository.getTransaction(options)

    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    await MemberRepository.excludeMembersFromSegments(ids, { ...options, transaction })
    await options.database.member.destroy({
      where: {
        id: ids,
        tenantId: currentTenant.id,
      },
      force,
      transaction,
    })
  }

  static async getMemberSegments(
    memberId: string,
    options: IRepositoryOptions,
  ): Promise<SegmentData[]> {
    const transaction = SequelizeRepository.getTransaction(options)
    const seq = SequelizeRepository.getSequelize(options)
    const segmentRepository = new SegmentRepository(options)

    const query = `
        SELECT "segmentId"
        FROM "memberSegments"
        WHERE "memberId" = :memberId
        ORDER BY "createdAt";
    `

    const data = await seq.query(query, {
      replacements: {
        memberId,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    const segmentIds = (data as any[]).map((item) => item.segmentId)
    const segments = await segmentRepository.findInIds(segmentIds)

    return segments
  }

  static async getActivityAggregates(
    memberId: string,
    options: IRepositoryOptions,
    segmentId?: string,
  ): Promise<ActivityAggregates> {
    const transaction = SequelizeRepository.getTransaction(options)
    const seq = SequelizeRepository.getSequelize(options)
    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    const replacements: Record<string, unknown> = {
      memberId,
      tenantId: currentTenant.id,
    }

    // query for all leaf segment ids
    let extraCTEs = `
      leaf_segment_ids AS (
        select id
        from segments
        where "tenantId" = :tenantId and "parentSlug" is not null and "grandparentSlug" is not null
      )
    `

    if (segmentId) {
      // we load data for a specific segment (can be leaf, parent or grand parent id)
      replacements.segmentId = segmentId
      extraCTEs = `
        input_segment AS (
          select
            id,
            slug,
            "parentSlug",
            "grandparentSlug"
          from segments
          where id = :segmentId
            and "tenantId" = :tenantId
        ),
        segment_level AS (
          select
            case
              when "parentSlug" is not null and "grandparentSlug" is not null
                  then 'child'
              when "parentSlug" is not null and "grandparentSlug" is null
                  then 'parent'
              when "parentSlug" is null and "grandparentSlug" is null
                  then 'grandparent'
              end as level,
            id,
            slug,
            "parentSlug",
            "grandparentSlug"
          from input_segment
        ),
        leaf_segment_ids AS (
          select s.id
          from segments s
          join segment_level sl on (sl.level = 'child' and s.id = sl.id)
              or (sl.level = 'parent' and s."parentSlug" = sl.slug and s."grandparentSlug" is not null)
              or (sl.level = 'grandparent' and s."grandparentSlug" = sl.slug)
        )
      `
    }

    const query = `
      with ${extraCTEs}
        SELECT
        a."memberId",
        a."segmentId",
        count(a.id)::integer AS "activityCount",
        max(a.timestamp) AS "lastActive",
        array_agg(DISTINCT concat(a.platform, ':', a.type)) FILTER (WHERE a.platform IS NOT NULL) AS "activityTypes",
        array_agg(DISTINCT a.platform) FILTER (WHERE a.platform IS NOT NULL) AS "activeOn",
        count(DISTINCT a."timestamp"::date)::integer AS "activeDaysCount",
        round(avg(
            CASE WHEN (a.sentiment ->> 'sentiment'::text) IS NOT NULL THEN
                (a.sentiment ->> 'sentiment'::text)::double precision
            ELSE
                NULL::double precision
            END
        )::numeric, 2):: float AS "averageSentiment"
        FROM activities a
        join leaf_segment_ids lfs on a."segmentId" = lfs.id
        WHERE a."memberId" = :memberId
        and a."tenantId" = :tenantId
        GROUP BY a."memberId", a."segmentId"
    `

    const data: ActivityAggregates[] = await seq.query(query, {
      replacements,
      type: QueryTypes.SELECT,
      transaction,
    })

    return data?.[0] || null
  }

  static async setAffiliations(
    memberId: string,
    data: MemberSegmentAffiliation[],
    options: IRepositoryOptions,
  ): Promise<void> {
    const affiliationRepository = new MemberSegmentAffiliationRepository(options)
    await affiliationRepository.setForMember(memberId, data)
    await MemberAffiliationRepository.update(memberId, options)
  }

  static async getAffiliations(
    memberId: string,
    options: IRepositoryOptions,
  ): Promise<MemberSegmentAffiliationJoined[]> {
    const transaction = SequelizeRepository.getTransaction(options)
    const seq = SequelizeRepository.getSequelize(options)

    const query = `
      select 
        msa.id,
        s.id as "segmentId", 
        s.slug as "segmentSlug",
        s.name as "segmentName",
        s."parentName" as "segmentParentName", 
        o.id as "organizationId", 
        o."displayName" as "organizationName",
        o.logo as "organizationLogo",
        msa."dateStart" as "dateStart",
        msa."dateEnd" as "dateEnd"
      from "memberSegmentAffiliations" msa 
      left join organizations o on o.id = msa."organizationId"
      join segments s on s.id = msa."segmentId"
      where msa."memberId" = :memberId
    `

    const data = await seq.query(query, {
      replacements: {
        memberId,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    return data as MemberSegmentAffiliationJoined[]
  }

  static async getIdentities(
    memberIds: string[],
    options: IRepositoryOptions,
  ): Promise<Map<string, IMemberIdentity[]>> {
    const results = new Map<string, IMemberIdentity[]>()

    const transaction = SequelizeRepository.getTransaction(options)
    const seq = SequelizeRepository.getSequelize(options)

    const query = `
      select "memberId", platform, username, "sourceId", "integrationId", "createdAt" from "memberIdentities" where "memberId" in (:memberIds)
      order by "createdAt" asc;
    `

    const data = await seq.query(query, {
      replacements: {
        memberIds,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    for (const id of memberIds) {
      results.set(id, [])
    }

    for (const res of data as any[]) {
      const { memberId, platform, username, sourceId, integrationId, createdAt } = res
      const identities = results.get(memberId)

      identities.push({
        platform,
        username,
        sourceId,
        integrationId,
        createdAt,
      })
    }

    return results
  }

  static async findById(
    id,
    options: IRepositoryOptions,
    returnPlain = true,
    doPopulateRelations = true,
    ignoreTenant = false,
    segmentId?: string,
  ) {
    const transaction = SequelizeRepository.getTransaction(options)

    const include = [
      {
        model: options.database.organization,
        attributes: ['id', 'displayName'],
        as: 'organizations',
        order: [['createdAt', 'ASC']],
        through: {
          attributes: ['memberId', 'organizationId', 'dateStart', 'dateEnd', 'title', 'source'],
          where: {
            deletedAt: null,
          },
        },
      },
      {
        model: options.database.segment,
        as: 'segments',
        through: {
          attributes: [],
        },
      },
    ]

    const where: any = {
      id,
    }

    if (!ignoreTenant) {
      const currentTenant = SequelizeRepository.getCurrentTenant(options)
      where.tenantId = currentTenant.id
    }

    const record = await options.database.member.findOne({
      where,
      include,
      transaction,
    })

    if (!record) {
      throw new Error404()
    }

    if (doPopulateRelations) {
      return this._populateRelations(record, options, returnPlain, segmentId)
    }
    const data = record.get({ plain: returnPlain })

    MemberRepository.sortOrganizations(data.organizations)

    const identities = (await this.getIdentities([data.id], options)).get(data.id)

    data.username = {}
    for (const identity of identities) {
      if (data.username[identity.platform]) {
        data.username[identity.platform].push(identity.username)
      } else {
        data.username[identity.platform] = [identity.username]
      }
    }

    data.affiliations = await MemberRepository.getAffiliations(id, options)

    return data
  }

  static async filterIdInTenant(id, options: IRepositoryOptions) {
    return lodash.get(await this.filterIdsInTenant([id], options), '[0]', null)
  }

  static async filterIdsInTenant(ids, options: IRepositoryOptions) {
    if (!ids || !ids.length) {
      return []
    }

    const transaction = SequelizeRepository.getTransaction(options)

    const currentTenant = SequelizeRepository.getCurrentTenant(options)

    const where = {
      id: {
        [Op.in]: ids,
      },
      tenantId: currentTenant.id,
    }

    const records = await options.database.member.findAll({
      attributes: ['id'],
      where,
      transaction,
    })

    return records.map((record) => record.id)
  }

  static async count(filter, options: IRepositoryOptions) {
    const transaction = SequelizeRepository.getTransaction(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    return options.database.member.count({
      where: {
        ...filter,
        tenantId: tenant.id,
      },
      transaction,
    })
  }

  static async findAndCountActiveOpensearch(
    filter: IActiveMemberFilter,
    limit: number,
    offset: number,
    orderBy: string,
    options: IRepositoryOptions,
    attributesSettings = [] as AttributeData[],
    segments: string[] = [],
  ): Promise<PageData<IActiveMemberData>> {
    const tenant = SequelizeRepository.getCurrentTenant(options)

    const segmentsEnabled = await isFeatureEnabled(FeatureFlag.SEGMENTS, options)

    let originalSegment

    if (segmentsEnabled) {
      if (segments.length !== 1) {
        throw new Error400(
          `This operation can have exactly one segment. Found ${segments.length} segments.`,
        )
      }
      originalSegment = segments[0]

      const segmentRepository = new SegmentRepository(options)

      const segment = await segmentRepository.findById(originalSegment)

      if (segment === null) {
        return {
          rows: [],
          count: 0,
          limit,
          offset,
        }
      }

      if (SegmentRepository.isProjectGroup(segment)) {
        segments = (segment as SegmentProjectGroupNestedData).projects.reduce((acc, p) => {
          acc.push(...p.subprojects.map((sp) => sp.id))
          return acc
        }, [])
      } else if (SegmentRepository.isProject(segment)) {
        segments = (segment as SegmentProjectNestedData).subprojects.map((sp) => sp.id)
      } else {
        segments = [originalSegment]
      }
    } else {
      originalSegment = (await new SegmentRepository(options).getDefaultSegment()).id
    }

    const activityPageSize = 10000
    let activityOffset = 0

    const activityQuery = {
      query: {
        bool: {
          must: [
            {
              range: {
                date_timestamp: {
                  gte: filter.activityTimestampFrom,
                  lte: filter.activityTimestampTo,
                },
              },
            },
            {
              term: {
                uuid_tenantId: tenant.id,
              },
            },
          ],
        },
      },
      aggs: {
        group_by_member: {
          terms: {
            field: 'uuid_memberId',
            size: 10000000,
          },
          aggs: {
            activity_count: {
              value_count: {
                field: 'uuid_id',
              },
            },
            active_days_count: {
              cardinality: {
                field: 'date_timestamp',
                script: {
                  source: "doc['date_timestamp'].value.toInstant().toEpochMilli()/86400000",
                },
              },
            },
            active_members_bucket_sort: {
              bucket_sort: {
                sort: [{ activity_count: { order: 'desc' } }],
                size: activityPageSize,
                from: activityOffset,
              },
            },
          },
        },
      },
      size: 0,
    } as any

    if (filter.platforms) {
      const subQueries = filter.platforms.map((p) => ({ match_phrase: { keyword_platform: p } }))

      activityQuery.query.bool.must.push({
        bool: {
          should: subQueries,
        },
      })
    }

    if (filter.activityIsContribution === true) {
      activityQuery.query.bool.must.push({
        term: {
          bool_isContribution: true,
        },
      })
    }

    if (segmentsEnabled) {
      const subQueries = segments.map((s) => ({ term: { uuid_segmentId: s } }))

      activityQuery.query.bool.must.push({
        bool: {
          should: subQueries,
        },
      })
    }

    const direction = orderBy.split('_')[1].toLowerCase() === 'desc' ? 'desc' : 'asc'
    if (orderBy.startsWith('activityCount')) {
      activityQuery.aggs.group_by_member.aggs.active_members_bucket_sort.bucket_sort.sort = [
        { activity_count: { order: direction } },
      ]
    } else if (orderBy.startsWith('activeDaysCount')) {
      activityQuery.aggs.group_by_member.aggs.active_members_bucket_sort.bucket_sort.sort = [
        { active_days_count: { order: direction } },
      ]
    } else {
      throw new Error(`Invalid order by: ${orderBy}`)
    }

    const memberIds = []
    let memberMap = {}
    let activities

    do {
      activities = await options.opensearch.search({
        index: OpenSearchIndex.ACTIVITIES,
        body: activityQuery,
      })

      memberIds.push(...activities.body.aggregations.group_by_member.buckets.map((b) => b.key))

      memberMap = {
        ...memberMap,
        ...activities.body.aggregations.group_by_member.buckets.reduce((acc, b) => {
          acc[b.key] = {
            activityCount: b.activity_count,
            activeDaysCount: b.active_days_count,
          }

          return acc
        }, {}),
      }

      activityOffset += activityPageSize

      // update page
      activityQuery.aggs.group_by_member.aggs.active_members_bucket_sort.bucket_sort.from =
        activityOffset
    } while (activities.body.aggregations.group_by_member.buckets.length === activityPageSize)

    if (memberIds.length === 0) {
      return {
        rows: [],
        count: 0,
        limit,
        offset,
      }
    }

    const memberQueryPayload = {
      and: [
        {
          id: {
            in: memberIds,
          },
        },
      ],
    } as any

    if (filter.isBot === true) {
      memberQueryPayload.and.push({
        isBot: {
          eq: true,
        },
      })
    } else if (filter.isBot === false) {
      memberQueryPayload.and.push({
        isBot: {
          not: true,
        },
      })
    }

    if (filter.isTeamMember === true) {
      memberQueryPayload.and.push({
        isTeamMember: {
          eq: true,
        },
      })
    } else if (filter.isTeamMember === false) {
      memberQueryPayload.and.push({
        isTeamMember: {
          not: true,
        },
      })
    }

    if (filter.isOrganization === true) {
      memberQueryPayload.and.push({
        isOrganization: {
          eq: true,
        },
      })
    } else if (filter.isOrganization === false) {
      memberQueryPayload.and.push({
        isOrganization: {
          not: true,
        },
      })
    }

    // to retain the sort came from activity query
    const customSortFunction = {
      _script: {
        type: 'number',
        script: {
          lang: 'painless',
          source: `
              def memberId = doc['uuid_memberId'].value;
              return params.memberIds.indexOf(memberId);
            `,
          params: {
            memberIds: memberIds.map((i) => `${i}`),
          },
        },
        order: 'asc',
      },
    }

    const members = await this.findAndCountAllOpensearch(
      {
        filter: memberQueryPayload,
        attributesSettings,
        segments: [originalSegment],
        countOnly: false,
        limit,
        offset,
        customSortFunction,
      },
      options,
    )

    return {
      rows: members.rows.map((m) => {
        m.activityCount = memberMap[m.id].activityCount.value
        m.activeDaysCount = memberMap[m.id].activeDaysCount.value
        return m
      }),
      count: members.count,
      offset,
      limit,
    }
  }

  static async findAndCountActive(
    filter: IActiveMemberFilter,
    limit: number,
    offset: number,
    orderBy: string,
    options: IRepositoryOptions,
  ): Promise<PageData<IActiveMemberData>> {
    const tenant = SequelizeRepository.getCurrentTenant(options)
    const segmentIds = SequelizeRepository.getSegmentIds(options)

    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const conditions = ['m."tenantId" = :tenantId', 'ms."segmentId" in (:segmentIds)']
    const parameters: any = {
      tenantId: tenant.id,
      segmentIds,
      periodStart: filter.activityTimestampFrom,
      periodEnd: filter.activityTimestampTo,
    }

    if (filter.isTeamMember === true) {
      conditions.push("COALESCE((m.attributes->'isTeamMember'->'default')::boolean, false) = true")
    } else if (filter.isTeamMember === false) {
      conditions.push("COALESCE((m.attributes->'isTeamMember'->'default')::boolean, false) = false")
    }

    if (filter.isBot === true) {
      conditions.push("COALESCE((m.attributes->'isBot'->'default')::boolean, false) = true")
    } else if (filter.isBot === false) {
      conditions.push("COALESCE((m.attributes->'isBot'->'default')::boolean, false) = false")
    }

    if (filter.isOrganization === true) {
      conditions.push(
        "COALESCE((m.attributes->'isOrganization'->'default')::boolean, false) = true",
      )
    } else if (filter.isOrganization === false) {
      conditions.push(
        "COALESCE((m.attributes->'isOrganization'->'default')::boolean, false) = false",
      )
    }

    const activityConditions = ['1=1']

    if (filter.platforms && filter.platforms.length > 0) {
      activityConditions.push('platform in (:platforms)')
      parameters.platforms = filter.platforms
    }

    if (filter.activityIsContribution) {
      activityConditions.push('"isContribution" = (:isContribution)')
      parameters.isContribution = filter.activityIsContribution
    }

    const conditionsString = conditions.join(' and ')
    const activityConditionsString = activityConditions.join(' and ')

    const direction = orderBy.split('_')[1].toLowerCase() === 'desc' ? 'desc' : 'asc'
    let orderString: string
    if (orderBy.startsWith('activityCount')) {
      orderString = `ad."activityCount" ${direction}`
    } else if (orderBy.startsWith('activeDaysCount')) {
      orderString = `ad."activeDaysCount" ${direction}`
    } else {
      throw new Error(`Invalid order by: ${orderBy}`)
    }

    const limitCondition = `limit ${limit} offset ${offset}`
    const query = `
        WITH
            orgs AS (
                SELECT mo."memberId", JSON_AGG(ROW_TO_JSON(o.*)) AS organizations
                FROM "memberOrganizations" mo
                INNER JOIN organizations o ON mo."organizationId" = o.id
                WHERE mo."deletedAt" IS NULL
                GROUP BY mo."memberId"
            ),
            activity_data AS (
                SELECT
                    "memberId",
                    COUNT(id) AS "activityCount",
                    COUNT(DISTINCT timestamp::DATE) AS "activeDaysCount"
                FROM activities
                WHERE ${activityConditionsString}
                  AND timestamp >= :periodStart
                  AND timestamp < :periodEnd
                GROUP BY "memberId"
            ),
            identities AS (
                SELECT
                    mi."memberId",
                    ARRAY_AGG(DISTINCT mi.platform) AS identities,
                    JSONB_OBJECT_AGG(mi.platform, mi.usernames) AS username
                FROM (
                    SELECT
                        "memberId",
                        platform,
                        ARRAY_AGG(username) AS usernames
                    FROM (
                        SELECT
                            "memberId",
                            platform,
                            username,
                            "createdAt",
                            ROW_NUMBER() OVER (PARTITION BY "memberId", platform ORDER BY "createdAt" DESC) =
                            1 AS is_latest
                        FROM "memberIdentities"
                        WHERE "tenantId" = :tenantId
                    ) sub
                    WHERE is_latest
                    GROUP BY "memberId", platform
                ) mi
                GROUP BY mi."memberId"
            )
        SELECT
            m.id,
            m."displayName",
            i.username,
            i.identities,
            m.attributes,
            ad."activityCount",
            ad."activeDaysCount",
            m."joinedAt",
            COALESCE(o.organizations, JSON_BUILD_ARRAY()) AS organizations,
            COUNT(*) OVER () AS "totalCount"
        FROM members m
        INNER JOIN activity_data ad ON ad."memberId" = m.id
        INNER JOIN identities i ON i."memberId" = m.id
        LEFT JOIN orgs o ON o."memberId" = m.id
        JOIN "memberSegments" ms ON ms."memberId" = m.id
        WHERE ${conditionsString}
        ORDER BY ${orderString}
                     ${limitCondition};
    `

    options.log.debug(
      { query, filter, orderBy, limit, offset, test: orderBy.split('_')[1].toLowerCase() },
      'Active members query!',
    )

    const results = await seq.query(query, {
      replacements: parameters,
      type: QueryTypes.SELECT,
      transaction,
    })

    if (results.length === 0) {
      return {
        rows: [],
        count: 0,
        offset,
        limit,
      }
    }

    const count = parseInt((results[0] as any).totalCount, 10)
    const rows: IActiveMemberData[] = results.map((r) => {
      const row = r as any
      return {
        id: row.id,
        displayName: row.displayName,
        username: row.username,
        attributes: row.attributes,
        organizations: row.organizations,
        activityCount: parseInt(row.activityCount, 10),
        activeDaysCount: parseInt(row.activeDaysCount, 10),
        joinedAt: row.joinedAt,
      }
    })

    return {
      rows,
      count,
      offset,
      limit,
    }
  }

  public static MEMBER_QUERY_FILTER_COLUMN_MAP: Map<string, string> = new Map([
    ['isOrganization', "coalesce((m.attributes -> 'isOrganization' -> 'default')::boolean, false)"],
    ['isTeamMember', "coalesce((m.attributes -> 'isTeamMember' -> 'default')::boolean, false)"],
    ['isBot', "coalesce((m.attributes -> 'isBot' -> 'default')::boolean, false)"],
    ['activeOn', 'aggs."activeOn"'],
    ['activityCount', 'aggs."activityCount"'],
    ['activityTypes', 'aggs."activityTypes"'],
    ['activeDaysCount', 'aggs."activeDaysCount"'],
    ['lastActive', 'aggs."lastActive"'],
    ['averageSentiment', 'aggs."averageSentiment"'],
    ['identities', 'aggs.identities'],
    ['reach', "(m.reach -> 'total')::integer"],
    ['numberOfOpenSourceContributions', 'coalesce(jsonb_array_length(m.contributions), 0)'],

    ['id', 'm.id'],
    ['displayName', 'm."displayName"'],
    ['tenantId', 'm."tenantId"'],
    ['score', 'm.score'],
    ['lastEnriched', 'm."lastEnriched"'],
    ['joinedAt', 'm."joinedAt"'],
    ['importHash', 'm."importHash"'],
    ['createdAt', 'm."createdAt"'],
    ['updatedAt', 'm."updatedAt"'],
    ['emails', 'm.emails'],
  ])

  static async countMembersPerSegment(options: IRepositoryOptions, segmentIds: string[]) {
    const countResults = await MemberRepository.countMembers(options, segmentIds)
    return countResults.reduce((acc, curr: any) => {
      acc[curr.segmentId] = parseInt(curr.totalCount, 10)
      return acc
    }, {})
  }

  static async countMembers(
    options: IRepositoryOptions,
    segmentIds: string[],
    filterString: string = '1=1',
    params: any = {},
  ) {
    const countQuery = `
        WITH
            member_tags AS (
                SELECT
                    mt."memberId",
                    JSONB_AGG(t.id) AS all_ids
                FROM "memberTags" mt
                INNER JOIN members m ON mt."memberId" = m.id
                JOIN "memberSegments" ms ON ms."memberId" = m.id
                INNER JOIN tags t ON mt."tagId" = t.id
                WHERE m."tenantId" = :tenantId
                  AND m."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND t."tenantId" = :tenantId
                  AND t."deletedAt" IS NULL
                GROUP BY mt."memberId"
            ),
            member_organizations AS (
                SELECT
                    mo."memberId",
                    JSONB_AGG(o.id) AS all_ids
                FROM "memberOrganizations" mo
                INNER JOIN members m ON mo."memberId" = m.id
                INNER JOIN organizations o ON mo."organizationId" = o.id
                JOIN "memberSegments" ms ON ms."memberId" = m.id
                JOIN "organizationSegments" os ON o.id = os."organizationId"
                WHERE m."tenantId" = :tenantId
                  AND m."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND o."tenantId" = :tenantId
                  AND o."deletedAt" IS NULL
                  AND os."segmentId" IN (:segmentIds)
                  AND mo."deletedAt" IS NULL
                GROUP BY mo."memberId"
            )
        SELECT
            COUNT(m.id) AS "totalCount",
            ms."segmentId"
        FROM members m
        JOIN "memberSegments" ms ON ms."memberId" = m.id
        INNER JOIN "memberActivityAggregatesMVs" aggs ON aggs.id = m.id AND aggs."segmentId" = ms."segmentId"
        LEFT JOIN member_tags mt ON m.id = mt."memberId"
        LEFT JOIN member_organizations mo ON m.id = mo."memberId"
        WHERE m."deletedAt" IS NULL
          AND m."tenantId" = :tenantId
          AND ms."segmentId" IN (:segmentIds)
          AND ${filterString}
        GROUP BY ms."segmentId";
    `

    const seq = SequelizeRepository.getSequelize(options)
    return seq.query(countQuery, {
      replacements: {
        tenantId: options.currentTenant.id,
        segmentIds,
        ...params,
      },
      type: QueryTypes.SELECT,
    })
  }

  static async findAndCountAllv2(
    {
      filter = {} as any,
      limit = 20,
      offset = 0,
      orderBy = 'joinedAt_DESC',
      countOnly = false,
      attributesSettings = [] as AttributeData[],
    },
    options: IRepositoryOptions,
  ): Promise<PageData<any>> {
    const tenant = SequelizeRepository.getCurrentTenant(options)
    const segmentIds = SequelizeRepository.getSegmentIds(options)
    const seq = SequelizeRepository.getSequelize(options)

    const params: any = {
      tenantId: tenant.id,
      segmentIds,
      limit,
      offset,
    }

    let orderByString = ''
    const orderByParts = orderBy.split('_')
    const direction = orderByParts[1].toLowerCase()
    switch (orderByParts[0]) {
      case 'joinedAt':
        orderByString = 'm."joinedAt"'
        break
      case 'displayName':
        orderByString = 'm."displayName"'
        break
      case 'reach':
        orderByString = "(m.reach ->> 'total')::int"
        break
      case 'score':
        orderByString = 'm.score'
        break
      case 'lastActive':
        orderByString = 'aggs."lastActive"'
        break
      case 'averageSentiment':
        orderByString = 'aggs."averageSentiment"'
        break
      case 'activeDaysCount':
        orderByString = 'aggs."activeDaysCount"'
        break
      case 'activityCount':
        orderByString = 'aggs."activityCount"'
        break
      case 'numberOfOpenSourceContributions':
        orderByString = '"numberOfOpenSourceContributions"'
        break

      default:
        throw new Error(`Invalid order by: ${orderBy}!`)
    }
    orderByString = `${orderByString} ${direction}`

    const jsonColumnInfos: JsonColumnInfo[] = [
      {
        property: 'attributes',
        column: 'm.attributes',
        attributeInfos: attributesSettings,
      },
      {
        property: 'username',
        column: 'aggs.username',
        attributeInfos: ALL_PLATFORM_TYPES.map((p) => ({
          name: p,
          type: MemberAttributeType.STRING,
        })),
      },
      {
        property: 'tags',
        column: 'mt.all_ids',
        attributeInfos: [],
      },
      {
        property: 'organizations',
        column: 'mo.all_ids',
        attributeInfos: [],
      },
    ]

    let filterString = RawQueryParser.parseFilters(
      filter,
      MemberRepository.MEMBER_QUERY_FILTER_COLUMN_MAP,
      jsonColumnInfos,
      params,
    )
    if (filterString.trim().length === 0) {
      filterString = '1=1'
    }

    const query = `
        WITH
            to_merge_data AS (
                SELECT mtm."memberId", STRING_AGG(DISTINCT mtm."toMergeId"::TEXT, ',') AS to_merge_ids
                FROM "memberToMerge" mtm
                INNER JOIN members m ON mtm."memberId" = m.id
                INNER JOIN members m2 ON mtm."toMergeId" = m2.id
                JOIN "memberSegments" ms ON m.id = ms."memberId"
                JOIN "memberSegments" ms2 ON m2.id = ms2."memberId"
                WHERE m."tenantId" = :tenantId
                  AND m2."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND ms2."segmentId" IN (:segmentIds)
                GROUP BY mtm."memberId"
            ),
            no_merge_data AS (
                SELECT mnm."memberId", STRING_AGG(DISTINCT mnm."noMergeId"::TEXT, ',') AS no_merge_ids
                FROM "memberNoMerge" mnm
                INNER JOIN members m ON mnm."memberId" = m.id
                INNER JOIN members m2 ON mnm."noMergeId" = m2.id
                JOIN "memberSegments" ms ON m.id = ms."memberId"
                JOIN "memberSegments" ms2 ON m2.id = ms2."memberId"
                WHERE m."tenantId" = :tenantId
                  AND m2."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND ms2."segmentId" IN (:segmentIds)
                GROUP BY mnm."memberId"
            ),
            member_tags AS (
                SELECT
                    mt."memberId",
                    JSON_AGG(
                            DISTINCT JSONB_BUILD_OBJECT(
                                    'id', t.id,
                                    'name', t.name
                                )
                        ) AS all_tags,
                    JSONB_AGG(t.id) AS all_ids
                FROM "memberTags" mt
                INNER JOIN members m ON mt."memberId" = m.id
                JOIN "memberSegments" ms ON ms."memberId" = m.id
                INNER JOIN tags t ON mt."tagId" = t.id
                WHERE m."tenantId" = :tenantId
                  AND m."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND t."tenantId" = :tenantId
                  AND t."deletedAt" IS NULL
                GROUP BY mt."memberId"
            ),
            member_organizations AS (
                SELECT
                    mo."memberId",
                    JSON_AGG(
                            ROW_TO_JSON(o.*)
                        ) AS all_organizations,
                    JSONB_AGG(o.id) AS all_ids
                FROM "memberOrganizations" mo
                INNER JOIN members m ON mo."memberId" = m.id
                INNER JOIN organizations o ON mo."organizationId" = o.id
                JOIN "memberSegments" ms ON ms."memberId" = m.id
                JOIN "organizationSegments" os ON o.id = os."organizationId"
                WHERE m."tenantId" = :tenantId
                  AND m."deletedAt" IS NULL
                  AND ms."segmentId" IN (:segmentIds)
                  AND o."tenantId" = :tenantId
                  AND o."deletedAt" IS NULL
                  AND os."segmentId" IN (:segmentIds)
                  AND ms."segmentId" = os."segmentId"
                  AND mo."deletedAt" IS NULL
                GROUP BY mo."memberId"
            ),
            aggs AS (
                SELECT
                    id,
                    MAX("lastActive") AS "lastActive",
                    ARRAY(SELECT DISTINCT UNNEST(ARRAY_AGG(identities))) AS identities,
                    jsonb_merge_agg(username) AS username,
                    SUM("activityCount") AS "activityCount",
                    ARRAY(SELECT DISTINCT UNNEST(array_accum("activityTypes"))) AS "activityTypes",
                    ARRAY(SELECT DISTINCT UNNEST(array_accum("activeOn"))) AS "activeOn",
                    SUM("activeDaysCount") AS "activeDaysCount",
                    ROUND(SUM("averageSentiment" * "activityCount") / SUM("activityCount"), 2) AS "averageSentiment",
                    ARRAY_AGG(DISTINCT "segmentId") AS "segmentIds"
                FROM "memberActivityAggregatesMVs"
                WHERE "segmentId" IN (:segmentIds)
                GROUP BY id
            )
        SELECT
            m.id,
            m."displayName",
            m.attributes,
            m.emails,
            m."tenantId",
            m.score,
            m."lastEnriched",
            m.contributions,
            m."joinedAt",
            m."importHash",
            m."createdAt",
            m."updatedAt",
            m.reach,
            tmd.to_merge_ids AS "toMergeIds",
            nmd.no_merge_ids AS "noMergeIds",
            aggs.username,
            aggs.identities,
            aggs."activeOn",
            aggs."activityCount",
            aggs."activityTypes",
            aggs."activeDaysCount",
            aggs."lastActive",
            aggs."averageSentiment",
            aggs."segmentIds",
            COALESCE(mt.all_tags, JSON_BUILD_ARRAY()) AS tags,
            COALESCE(mo.all_organizations, JSON_BUILD_ARRAY()) AS organizations,
            COALESCE(JSONB_ARRAY_LENGTH(m.contributions), 0) AS "numberOfOpenSourceContributions"
        FROM members m
        INNER JOIN aggs ON aggs.id = m.id
        LEFT JOIN to_merge_data tmd ON m.id = tmd."memberId"
        LEFT JOIN no_merge_data nmd ON m.id = nmd."memberId"
        LEFT JOIN member_tags mt ON m.id = mt."memberId"
        LEFT JOIN member_organizations mo ON m.id = mo."memberId"
        WHERE m."deletedAt" IS NULL
          AND m."tenantId" = :tenantId
          AND ${filterString}
        ORDER BY ${orderByString}
        LIMIT :limit OFFSET :offset;
    `

    const sumMemberCount = (countResults) =>
      countResults.map((row) => parseInt(row.totalCount, 10)).reduce((a, b) => a + b, 0)

    if (countOnly) {
      const countResults = await MemberRepository.countMembers(
        options,
        segmentIds,
        filterString,
        params,
      )
      const count = sumMemberCount(countResults)

      return {
        rows: [],
        count,
        limit,
        offset,
      }
    }

    const [results, countResults] = await Promise.all([
      seq.query(query, {
        replacements: params,
        type: QueryTypes.SELECT,
      }),
      MemberRepository.countMembers(options, segmentIds, filterString, params),
    ])

    const memberIds = results.map((r) => (r as any).id)
    if (memberIds.length > 0) {
      const lastActivities = await seq.query(
        `
            WITH
                raw_data AS (
                    SELECT *, ROW_NUMBER() OVER (PARTITION BY "memberId" ORDER BY timestamp DESC) AS rn
                    FROM activities
                    WHERE "tenantId" = :tenantId
                      AND "memberId" IN (:memberIds)
                      AND "segmentId" IN (:segmentIds)
                )
            SELECT *
            FROM raw_data
            WHERE rn = 1;
        `,
        {
          replacements: {
            tenantId: tenant.id,
            segmentIds,
            memberIds,
          },
          type: QueryTypes.SELECT,
        },
      )

      for (const row of results) {
        const r = row as any
        r.lastActivity = lastActivities.find((a) => (a as any).memberId === r.id)
        if (r.lastActivity) {
          r.lastActivity.display = ActivityDisplayService.getDisplayOptions(
            r.lastActivity,
            SegmentRepository.getActivityTypes(options),
            [ActivityDisplayVariant.SHORT, ActivityDisplayVariant.CHANNEL],
          )
        }
      }
    }

    const count = sumMemberCount(countResults)

    return {
      rows: results,
      count,
      limit,
      offset,
    }
  }

  static async findAndCountAllOpensearch(
    {
      filter = {} as any,
      limit = 20,
      offset = 0,
      orderBy = 'joinedAt_DESC',
      countOnly = false,
      attributesSettings = [] as AttributeData[],
      segments = [] as string[],
      customSortFunction = undefined,
    },
    options: IRepositoryOptions,
  ): Promise<PageData<any>> {
    const tenant = SequelizeRepository.getCurrentTenant(options)

    const segmentsEnabled = await isFeatureEnabled(FeatureFlag.SEGMENTS, options)

    const segment = segments[0]

    const translator = FieldTranslatorFactory.getTranslator(
      OpenSearchIndex.MEMBERS,
      attributesSettings,
      [
        'default',
        'custom',
        'crowd',
        'enrichment',
        ...(await TenantRepository.getAvailablePlatforms(options.currentTenant.id, options)).map(
          (p) => p.platform,
        ),
      ],
    )

    const parsed = OpensearchQueryParser.parse(
      { filter, limit, offset, orderBy },
      OpenSearchIndex.MEMBERS,
      translator,
    )

    // add tenant filter to parsed query
    parsed.query.bool.must.push({
      term: {
        uuid_tenantId: tenant.id,
      },
    })

    if (segmentsEnabled) {
      // add segment filter
      parsed.query.bool.must.push({
        term: {
          uuid_segmentId: segment,
        },
      })
    }

    if (customSortFunction) {
      parsed.sort = customSortFunction
    }

    if (filter.organizations && filter.organizations.length > 0) {
      parsed.query.bool.must = parsed.query.bool.must.filter(
        (d) => d.nested?.query?.term?.['nested_organizations.uuid_id'] === undefined,
      )

      // add organizations filter manually for now

      for (const organizationId of filter.organizations) {
        parsed.query.bool.must.push({
          nested: {
            path: 'nested_organizations',
            query: {
              bool: {
                must: [
                  {
                    term: {
                      'nested_organizations.uuid_id': organizationId,
                    },
                  },
                  {
                    bool: {
                      must_not: {
                        exists: {
                          field: 'nested_organizations.obj_memberOrganizations.date_dateEnd',
                        },
                      },
                    },
                  },
                ],
              },
            },
          },
        })
      }
    }

    const countResponse = await options.opensearch.count({
      index: OpenSearchIndex.MEMBERS,
      body: { query: parsed.query },
    })

    if (countOnly) {
      return {
        rows: [],
        count: countResponse.body.count,
        limit,
        offset,
      }
    }

    const response = await options.opensearch.search({
      index: OpenSearchIndex.MEMBERS,
      body: parsed,
    })

    const translatedRows = response.body.hits.hits.map((o) =>
      translator.translateObjectToCrowd(o._source),
    )

    for (const row of translatedRows) {
      const identities = []
      const username: {} = {}

      for (const identity of row.identities) {
        identities.push(identity.platform)
        if (identity.platform in username) {
          username[identity.platform].push(identity.username)
        } else {
          username[identity.platform] = [identity.username]
        }
      }

      row.identities = identities
      row.username = username
      row.activeDaysCount = parseInt(row.activeDaysCount, 10)
      row.activityCount = parseInt(row.activityCount, 10)
    }

    const memberIds = translatedRows.map((r) => r.id)
    if (memberIds.length > 0) {
      const seq = SequelizeRepository.getSequelize(options)
      const segmentIds = segments

      const lastActivities = await seq.query(
        `
            WITH
                raw_data AS (
                    SELECT *, ROW_NUMBER() OVER (PARTITION BY "memberId" ORDER BY timestamp DESC) AS rn
                    FROM activities
                    WHERE "tenantId" = :tenantId
                      AND "memberId" IN (:memberIds)
                      AND "segmentId" IN (:segmentIds)
                )
            SELECT *
            FROM raw_data
            WHERE rn = 1;
        `,
        {
          replacements: {
            tenantId: tenant.id,
            segmentIds,
            memberIds,
          },
          type: QueryTypes.SELECT,
        },
      )

      for (const row of translatedRows) {
        const r = row as any
        r.lastActivity = lastActivities.find((a) => (a as any).memberId === r.id)
        if (r.lastActivity) {
          r.lastActivity.display = ActivityDisplayService.getDisplayOptions(
            r.lastActivity,
            SegmentRepository.getActivityTypes(options),
            [ActivityDisplayVariant.SHORT, ActivityDisplayVariant.CHANNEL],
          )
        }
      }
    }

    return { rows: translatedRows, count: countResponse.body.count, limit, offset }
  }

  static async findAndCountAll(
    {
      filter = {} as any,
      advancedFilter = null as any,
      limit = 0,
      offset = 0,
      orderBy = '',
      attributesSettings = [] as AttributeData[],
      exportMode = false,
    },

    options: IRepositoryOptions,
  ) {
    let customOrderBy: Array<any> = []
    const include = [
      {
        model: options.database.memberActivityAggregatesMV,
        attributes: [],
        required: true,
        as: 'memberActivityAggregatesMVs',
      },
      {
        model: options.database.member,
        as: 'toMerge',
        attributes: [],
        through: {
          attributes: [],
        },
      },
      {
        model: options.database.member,
        as: 'noMerge',
        attributes: [],
        through: {
          attributes: [],
        },
      },
    ]

    customOrderBy = customOrderBy.concat(
      SequelizeFilterUtils.customOrderByIfExists('activityCount', orderBy),
    )

    customOrderBy = customOrderBy.concat(
      SequelizeFilterUtils.customOrderByIfExists('activeDaysCount', orderBy),
    )

    customOrderBy = customOrderBy.concat(
      SequelizeFilterUtils.customOrderByIfExists('lastActive', orderBy),
    )

    customOrderBy = customOrderBy.concat(
      SequelizeFilterUtils.customOrderByIfExists('averageSentiment', orderBy),
    )

    customOrderBy = customOrderBy.concat(
      SequelizeFilterUtils.customOrderByIfExists('numberOfOpenSourceContributions', orderBy),
    )

    if (orderBy.includes('reach')) {
      customOrderBy = customOrderBy.concat([
        Sequelize.literal(`("member".reach->'total')::int`),
        orderBy.split('_')[1],
      ])
    }

    if (!advancedFilter) {
      advancedFilter = { and: [] }

      if (filter) {
        if (filter.id) {
          advancedFilter.and.push({ id: filter.id })
        }

        if (filter.platform) {
          advancedFilter.and.push({
            platform: {
              jsonContains: filter.platform,
            },
          })
        }

        if (filter.tags) {
          advancedFilter.and.push({
            tags: filter.tags,
          })
        }

        if (filter.organizations) {
          advancedFilter.and.push({
            organizations: filter.organizations,
          })
        }

        // TODO: member identitites FIX
        if (filter.username) {
          advancedFilter.and.push({ username: { jsonContains: filter.username } })
        }

        if (filter.displayName) {
          advancedFilter.and.push({
            displayName: {
              textContains: filter.displayName,
            },
          })
        }

        if (filter.emails) {
          advancedFilter.and.push({
            emails: {
              contains: filter.emails,
            },
          })
        }

        if (filter.scoreRange) {
          const [start, end] = filter.scoreRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              score: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              score: {
                lte: end,
              },
            })
          }
        }

        if (filter.createdAtRange) {
          const [start, end] = filter.createdAtRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              createdAt: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              createdAt: {
                lte: end,
              },
            })
          }
        }

        if (filter.reachRange) {
          const [start, end] = filter.reachRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              reach: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              reach: {
                lte: end,
              },
            })
          }
        }

        if (filter.activityCountRange) {
          const [start, end] = filter.activityCountRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              activityCount: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              activityCount: {
                lte: end,
              },
            })
          }
        }

        if (filter.activityTypes) {
          advancedFilter.and.push({
            activityTypes: {
              overlap: filter.activityTypes.split(','),
            },
          })
        }
        if (filter.activeDaysCountRange) {
          const [start, end] = filter.activeDaysCountRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              activeDaysCount: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              activeDaysCount: {
                lte: end,
              },
            })
          }
        }

        if (filter.joinedAtRange) {
          const [start, end] = filter.joinedAtRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              joinedAt: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              joinedAt: {
                lte: end,
              },
            })
          }
        }

        if (filter.lastActiveRange) {
          const [start, end] = filter.lastActiveRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              lastActive: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              lastActive: {
                lte: end,
              },
            })
          }
        }

        if (filter.averageSentimentRange) {
          const [start, end] = filter.averageSentimentRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              averageSentiment: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              averageSentiment: {
                lte: end,
              },
            })
          }
        }

        if (filter.numberOfOpenSourceContributionsRange) {
          const [start, end] = filter.numberOfOpenSourceContributionsRange
          if (start !== undefined && start !== null && start !== '') {
            advancedFilter.and.push({
              numberOfOpenSourceContributions: {
                gte: start,
              },
            })
          }

          if (end !== undefined && end !== null && end !== '') {
            advancedFilter.and.push({
              numberOfOpenSourceContributions: {
                lte: end,
              },
            })
          }
        }
      }
    }

    const {
      dynamicAttributesDefaultNestedFields,
      dynamicAttributesPlatformNestedFields,
      dynamicAttributesProjection,
    } = await MemberRepository.getDynamicAttributesLiterals(attributesSettings, options)

    const activityCount = Sequelize.literal(`"memberActivityAggregatesMVs"."activityCount"`)
    const activityTypes = Sequelize.literal(`"memberActivityAggregatesMVs"."activityTypes"`)
    const activeDaysCount = Sequelize.literal(`"memberActivityAggregatesMVs"."activeDaysCount"`)
    const lastActive = Sequelize.literal(`"memberActivityAggregatesMVs"."lastActive"`)
    const activeOn = Sequelize.literal(`"memberActivityAggregatesMVs"."activeOn"`)

    const averageSentiment = Sequelize.literal(`"memberActivityAggregatesMVs"."averageSentiment"`)
    const identities = Sequelize.literal(`"memberActivityAggregatesMVs"."identities"`)
    const username = Sequelize.literal(`"memberActivityAggregatesMVs"."username"`)

    const toMergeArray = Sequelize.literal(`STRING_AGG( distinct "toMerge"."id"::text, ',')`)
    const noMergeArray = Sequelize.literal(`STRING_AGG( distinct "noMerge"."id"::text, ',')`)

    const numberOfOpenSourceContributions = Sequelize.literal(
      `COALESCE(jsonb_array_length("member"."contributions"), 0)`,
    )

    const parser = new QueryParser(
      {
        nestedFields: {
          ...dynamicAttributesDefaultNestedFields,
          reach: 'reach.total',
          username: 'username.asString',
        },
        aggregators: {
          activityCount,
          activityTypes,
          activeDaysCount,
          lastActive,
          averageSentiment,
          activeOn,
          identities,
          username,
          numberOfOpenSourceContributions,
          ...dynamicAttributesPlatformNestedFields,
          'reach.total': Sequelize.literal(`("member".reach->'total')::int`),
          'username.asString': Sequelize.literal(
            `CAST("memberActivityAggregatesMVs"."username" AS TEXT)`,
          ),
          ...SequelizeFilterUtils.getNativeTableFieldAggregations(
            [
              'id',
              'attributes',
              'displayName',
              'emails',
              'score',
              'lastEnriched',
              'enrichedBy',
              'contributions',
              'joinedAt',
              'importHash',
              'reach',
              'createdAt',
              'updatedAt',
              'createdById',
              'updatedById',
            ],
            'member',
          ),
        },
        manyToMany: {
          tags: {
            table: 'members',
            model: 'member',
            relationTable: {
              name: 'memberTags',
              from: 'memberId',
              to: 'tagId',
            },
          },
          organizations: {
            table: 'members',
            model: 'member',
            relationTable: {
              name: 'memberOrganizations',
              from: 'memberId',
              to: 'organizationId',
            },
          },
          segments: {
            table: 'members',
            model: 'member',
            relationTable: {
              name: 'memberSegments',
              from: 'memberId',
              to: 'segmentId',
            },
          },
        },
        // TODO: member identitites FIX
        // customOperators: {
        //   username: {
        //     model: 'member',
        //     column: 'username',
        //   },
        //   platform: {
        //     model: 'member',
        //     column: 'username',
        //   },
        // },
        exportMode,
      },
      options,
    )

    const parsed: QueryOutput = parser.parse({
      filter: advancedFilter,
      orderBy: orderBy || ['joinedAt_DESC'],
      limit,
      offset,
    })

    let order = parsed.order

    if (customOrderBy.length > 0) {
      order = [customOrderBy]
    }

    let {
      rows,
      count, // eslint-disable-line prefer-const
    } = await options.database.member.findAndCountAll({
      where: parsed.where ? parsed.where : {},
      having: parsed.having ? parsed.having : {},
      include,
      attributes: [
        ...SequelizeFilterUtils.getLiteralProjections(
          [
            'id',
            'attributes',
            'displayName',
            'emails',
            'tenantId',
            'score',
            'lastEnriched',
            'enrichedBy',
            'contributions',
            'joinedAt',
            'importHash',
            'createdAt',
            'updatedAt',
            'createdById',
            'updatedById',
            'reach',
          ],
          'member',
        ),
        [activeOn, 'activeOn'],
        [identities, 'identities'],
        [username, 'username'],
        [activityCount, 'activityCount'],
        [activityTypes, 'activityTypes'],
        [activeDaysCount, 'activeDaysCount'],
        [lastActive, 'lastActive'],
        [averageSentiment, 'averageSentiment'],
        [toMergeArray, 'toMergeIds'],
        [noMergeArray, 'noMergeIds'],
        [numberOfOpenSourceContributions, 'numberOfOpenSourceContributions'],
        ...dynamicAttributesProjection,
      ],
      limit: parsed.limit || 50,
      offset: offset ? Number(offset) : 0,
      order,
      subQuery: false,
      group: [
        'member.id',
        'memberActivityAggregatesMVs.activeOn',
        'memberActivityAggregatesMVs.activityCount',
        'memberActivityAggregatesMVs.activityTypes',
        'memberActivityAggregatesMVs.activeDaysCount',
        'memberActivityAggregatesMVs.lastActive',
        'memberActivityAggregatesMVs.averageSentiment',
        'memberActivityAggregatesMVs.username',
        'memberActivityAggregatesMVs.identities',
        'toMerge.id',
      ],
      distinct: true,
    })

    rows = await this._populateRelationsForRows(rows, attributesSettings, exportMode)

    return {
      rows,
      count: count.length,
      limit: limit ? Number(limit) : 50,
      offset: offset ? Number(offset) : 0,
    }
  }

  /**
   * Returns sequelize literals for dynamic member attributes.
   * @param memberAttributeSettings
   * @param options
   * @returns
   */
  static async getDynamicAttributesLiterals(
    memberAttributeSettings: AttributeData[],
    options: IRepositoryOptions,
  ) {
    // get possible platforms for a tenant
    const availableDynamicAttributePlatformKeys = [
      'default',
      'custom',
      ...(await TenantRepository.getAvailablePlatforms(options.currentTenant.id, options)).map(
        (p) => p.platform,
      ),
    ]

    const dynamicAttributesDefaultNestedFields = memberAttributeSettings.reduce(
      (acc, attribute) => {
        acc[attribute.name] = `attributes.${attribute.name}.default`
        return acc
      },
      {},
    )

    const dynamicAttributesPlatformNestedFields = memberAttributeSettings.reduce(
      (acc, attribute) => {
        for (const key of availableDynamicAttributePlatformKeys) {
          if (attribute.type === MemberAttributeType.NUMBER) {
            acc[`attributes.${attribute.name}.${key}`] = Sequelize.literal(
              `("member"."attributes"#>>'{${attribute.name},${key}}')::integer`,
            )
          } else if (attribute.type === MemberAttributeType.BOOLEAN) {
            acc[`attributes.${attribute.name}.${key}`] = Sequelize.literal(
              `("member"."attributes"#>>'{${attribute.name},${key}}')::boolean`,
            )
          } else if (attribute.type === MemberAttributeType.MULTI_SELECT) {
            acc[`attributes.${attribute.name}.${key}`] = Sequelize.literal(
              `ARRAY( SELECT jsonb_array_elements_text("member"."attributes"#>'{${attribute.name},${key}}'))`,
            )
          } else {
            acc[`attributes.${attribute.name}.${key}`] = Sequelize.literal(
              `"member"."attributes"#>>'{${attribute.name},${key}}'`,
            )
          }
        }
        return acc
      },
      {},
    )

    const dynamicAttributesProjection = memberAttributeSettings.reduce((acc, attribute) => {
      for (const key of availableDynamicAttributePlatformKeys) {
        if (key === 'default') {
          acc.push([
            Sequelize.literal(`"member"."attributes"#>>'{${attribute.name},default}'`),
            attribute.name,
          ])
        } else {
          acc.push([
            Sequelize.literal(`"member"."attributes"#>>'{${attribute.name},${key}}'`),
            `${attribute.name}.${key}`,
          ])
        }
      }
      return acc
    }, [])

    return {
      dynamicAttributesDefaultNestedFields,
      dynamicAttributesPlatformNestedFields,
      availableDynamicAttributePlatformKeys,
      dynamicAttributesProjection,
    }
  }

  static async findAllAutocomplete(query, limit, options: IRepositoryOptions) {
    const tenant = SequelizeRepository.getCurrentTenant(options)

    const whereAnd: Array<any> = [
      {
        tenantId: tenant.id,
      },
    ]

    if (query) {
      whereAnd.push({
        [Op.or]: [
          {
            displayName: {
              [Op.iLike]: `${query}%`,
            },
          },
        ],
      })
    }

    const where = { [Op.and]: whereAnd }

    const records = await options.database.member.findAll({
      attributes: ['id', 'displayName', 'attributes', 'emails'],
      where,
      limit: limit ? Number(limit) : undefined,
      order: [['displayName', 'ASC']],
      include: [
        {
          model: options.database.organization,
          attributes: ['id', 'displayName'],
          as: 'organizations',
        },
        {
          model: options.database.segment,
          as: 'segments',
          where: {
            id: SequelizeRepository.getSegmentIds(options),
          },
        },
      ],
    })

    return records.map((record) => ({
      id: record.id,
      label: record.displayName,
      email: record.emails.length > 0 ? record.emails[0] : null,
      avatar: record.attributes?.avatarUrl?.default || null,
      organizations: record.organizations.map((org) => ({
        id: org.id,
        name: org.name,
      })),
    }))
  }

  static async mergeSuggestionsByUsername(
    numberOfHours,
    options: IRepositoryOptions,
  ): Promise<IMemberMergeSuggestion[]> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const segmentIds = SequelizeRepository.getSegmentIds(options)

    const query = `
    -- Define a CTE named "new_members" to get members created in the last 2 hours with a specific tenantId
    WITH new_members AS (
      SELECT m.id, m."tenantId"
      FROM members m
      JOIN "memberSegments" ms ON ms."memberId" = m.id
      WHERE m."createdAt" >= now() - INTERVAL :numberOfHours
      AND m."tenantId" = :tenantId
      AND ms."segmentId" IN (:segmentIds)
    ),
    -- Define a CTE named "identity_join" to find members with the same usernames across different platforms
    identity_join AS (
      SELECT
        m1.id AS m1_id,
        m2.id AS m2_id,
        i1.platform AS i1_platform,
        i2.platform AS i2_platform,
        i1.username AS i1_username,
        i2.username AS i2_username
      FROM new_members m1
      -- Join memberIdentities and members to get related records
      JOIN "memberIdentities" i1 ON m1.id = i1."memberId"
      JOIN "memberIdentities" i2 ON i1.username = i2.username AND i1.platform <> i2.platform
      JOIN members m2 ON m2.id = i2."memberId"
      -- Filter out records where tenantId is different and memberIds are the same
      WHERE m1."tenantId" = m2."tenantId"
      AND m1.id <> m2.id
      -- Filter out records present in memberToMerge table
      AND NOT EXISTS (
        SELECT 1
        FROM "memberToMerge"
        WHERE (
          "memberId" = m1.id
          AND "toMergeId" = m2.id
        ) OR (
          "memberId" = m2.id
          AND "toMergeId" = m1.id
        )
      )
      -- Filter out records present in memberNoMerge table
      AND NOT EXISTS (
        SELECT 1
        FROM "memberNoMerge"
        WHERE (
          "memberId" = m1.id
          AND "noMergeId" = m2.id
        ) OR (
          "memberId" = m2.id
          AND "noMergeId" = m1.id
        )
      )
    )
    -- Select everything from the final CTE "identity_join"
    SELECT *
    FROM identity_join;`

    const suggestions = await seq.query(query, {
      replacements: {
        tenantId: tenant.id,
        segmentIds,
        numberOfHours: `${numberOfHours} hours`,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    return suggestions.map((suggestion: any) => ({
      members: [suggestion.m1_id, suggestion.m2_id],
      // 100% confidence only from emails
      similarity: 0.95,
    }))
  }

  static async mergeSuggestionsByEmail(
    numberOfHours,
    options: IRepositoryOptions,
  ): Promise<IMemberMergeSuggestion[]> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const segmentIds = SequelizeRepository.getSegmentIds(options)

    const query = `
    -- Define a CTE named "new_members" to get members created in the last 7 days with a specific tenantId and their emails
    WITH new_members AS (
      SELECT m.id, m."tenantId", m.emails
      FROM members m
      JOIN "memberSegments" ms ON ms."memberId" = m.id
      WHERE m."createdAt" >= now() - INTERVAL :numberOfHours
      AND m."tenantId" = :tenantId
      AND ms."segmentId" IN (:segmentIds)
    ),
    -- Define a CTE named "email_join" to find overlapping emails across different members
    email_join AS (
      SELECT
        m1.id AS m1_id,            -- Member 1 ID
        m2.id AS m2_id,            -- Member 2 ID
        m1.emails AS m1_emails,    -- Member 1 emails
        m2.emails AS m2_emails     -- Member 2 emails
      FROM new_members m1
      -- Join the members table on the tenantId field and ensuring the IDs are different
      JOIN members m2 ON m1."tenantId" = m2."tenantId"
        AND m1.id <> m2.id
      -- Filter for overlapping emails
      WHERE m1.emails && m2.emails
      -- Exclude pairs that are already in the memberToMerge table
      AND NOT EXISTS (
        SELECT 1
        FROM "memberToMerge"
        WHERE (
          "memberId" = m1.id
          AND "toMergeId" = m2.id
        ) OR (
          "memberId" = m2.id
          AND "toMergeId" = m1.id
        )
      )
      -- Exclude pairs that are in the memberNoMerge table
      AND NOT EXISTS (
        SELECT 1
        FROM "memberNoMerge"
        WHERE (
          "memberId" = m1.id
          AND "noMergeId" = m2.id
        ) OR (
          "memberId" = m2.id
          AND "noMergeId" = m1.id
        )
      )
    )
    -- Select all columns from the email_join CTE
    SELECT *
    FROM email_join;`

    const suggestions = await seq.query(query, {
      replacements: {
        tenantId: tenant.id,
        segmentIds,
        numberOfHours: `${numberOfHours} hours`,
      },
      type: QueryTypes.SELECT,
      transaction,
    })
    return suggestions.map((suggestion: any) => ({
      members: [suggestion.m1_id, suggestion.m2_id],
      similarity: 1,
    }))
  }

  static async mergeSuggestionsBySimilarity(
    numberOfHours,
    options: IRepositoryOptions,
  ): Promise<IMemberMergeSuggestion[]> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const segmentIds = SequelizeRepository.getSegmentIds(options)

    const query = `
    -- Define a CTE named "new_members" to get members created in the last 7 days with a specific tenantId
    WITH new_members AS (
      SELECT m.*
      FROM members m
      JOIN "memberSegments" ms ON ms."memberId" = m.id
      WHERE m."createdAt" >= now() - INTERVAL :numberOfHours
      AND m."tenantId" = :tenantId
      AND ms."segmentId" IN (:segmentIds)
      LIMIT 1000
    ),
    -- Define a CTE named "identity_join" to find similar identities across platforms
    identity_join AS (
      -- Select distinct pairs of memberIds and relevant information, along with the similarity score
      SELECT DISTINCT ON(m1_id, m2_id)
        m1.id AS m1_id,
        m2.id AS m2_id,
        similarity(i1.username, i2.username) AS similarity
      FROM new_members m1
      -- Join memberIdentities and members to get related records
      JOIN "memberIdentities" i1 ON m1.id = i1."memberId"
      JOIN "memberIdentities" i2 ON i1.platform <> i2.platform
      JOIN members m2 ON m2.id = i2."memberId"
      -- Filter out records where tenantId is different and memberIds are the same
      WHERE m1."tenantId" = m2."tenantId"
      AND m1.id <> m2.id
      -- Consider only records with similarity > 0.5 (adjust this threshold as needed)
      AND similarity(i1.username, i2.username) > 0.5
      -- Order by similarity descending to get the most similar records first
      ORDER BY m1_id, m2_id, similarity DESC
    ),
    -- Define a CTE named "exclude_already_processed" to remove the already processed members
    exclude_already_processed AS (
      SELECT *
      FROM identity_join
      -- Filter out records present in memberToMerge table
      WHERE NOT EXISTS (
        SELECT 1
        FROM "memberToMerge"
        WHERE (
          "memberId" = identity_join.m1_id
          AND "toMergeId" = identity_join.m2_id
        ) OR (
          "memberId" = identity_join.m2_id
          AND "toMergeId" = identity_join.m1_id
        )
        -- Filter out records present in memberNoMerge table
      ) AND NOT EXISTS (
        SELECT 1
        FROM "memberNoMerge"
        WHERE (
          "memberId" = identity_join.m1_id
          AND "noMergeId" = identity_join.m2_id
        ) OR (
          "memberId" = identity_join.m2_id
          AND "noMergeId" = identity_join.m1_id
        )
      )
    )
    -- Select everything from the final CTE "exclude_already_processed"
    SELECT *
    FROM exclude_already_processed;`

    const suggestions = await seq.query(query, {
      replacements: {
        tenantId: tenant.id,
        segmentIds,
        numberOfHours: `${numberOfHours} hours`,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    return suggestions.map((suggestion: any) => ({
      members: [suggestion.m1_id, suggestion.m2_id],
      // 100% confidence only from emails
      similarity: suggestion.similarity > 0.95 ? 0.95 : suggestion.similarity,
    }))
  }

  static async addToWeakIdentities(
    memberIds: string[],
    username: string,
    platform: string,
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const tenant = SequelizeRepository.getCurrentTenant(options)

    const query = `
    update members
    set "weakIdentities" = "weakIdentities" || jsonb_build_object('username', :username, 'platform', :platform)::jsonb
    where id in (:memberIds)
      and not exists (select 1
                      from jsonb_array_elements("weakIdentities") as wi
                      where wi ->> 'username' = :username
                        and wi ->> 'platform' = :platform);
    `

    await seq.query(query, {
      replacements: {
        memberIds,
        username,
        platform,
        tenantId: tenant.id,
      },
      type: QueryTypes.UPDATE,
      transaction,
    })
  }

  static async _createAuditLog(action, record, data, options: IRepositoryOptions) {
    if (log) {
      let values = {}

      if (data) {
        values = {
          ...record.get({ plain: true }),
          activitiesIds: data.activities,
          tagsIds: data.tags,
          noMergeIds: data.noMerge,
        }
      }

      await AuditLogRepository.log(
        {
          entityName: 'member',
          entityId: record.id,
          action,
          values,
        },
        options,
      )
    }
  }

  static async _populateRelationsForRows(rows, attributesSettings, exportMode = false) {
    if (!rows) {
      return rows
    }

    // No need for lazyloading tags for integrations or microservices
    if (
      (KUBE_MODE &&
        (SERVICE === ServiceType.NODEJS_WORKER || SERVICE === ServiceType.JOB_GENERATOR) &&
        !exportMode) ||
      process.env.SERVICE === 'integrations' ||
      process.env.SERVICE === 'microservices-nodejs'
    ) {
      return rows.map((record) => {
        const plainRecord = record.get({ plain: true })
        plainRecord.noMerge = plainRecord.noMergeIds ? plainRecord.noMergeIds.split(',') : []
        plainRecord.toMerge = plainRecord.toMergeIds ? plainRecord.toMergeIds.split(',') : []

        delete plainRecord.toMergeIds
        delete plainRecord.noMergeIds
        return plainRecord
      })
    }

    return Promise.all(
      rows.map(async (record) => {
        const plainRecord = record.get({ plain: true })
        plainRecord.noMerge = plainRecord.noMergeIds ? plainRecord.noMergeIds.split(',') : []
        plainRecord.toMerge = plainRecord.toMergeIds ? plainRecord.toMergeIds.split(',') : []
        plainRecord.lastActivity = plainRecord.lastActive
          ? (
              await record.getActivities({
                order: [['timestamp', 'DESC']],
                limit: 1,
              })
            )[0].get({ plain: true })
          : null
        delete plainRecord.toMergeIds
        delete plainRecord.noMergeIds

        plainRecord.activeOn = plainRecord.activeOn ?? []

        for (const attribute of attributesSettings) {
          if (Object.prototype.hasOwnProperty.call(plainRecord, attribute.name)) {
            delete plainRecord[attribute.name]
          }
        }

        for (const attributeName in plainRecord.attributes) {
          if (!lodash.find(attributesSettings, { name: attributeName })) {
            delete plainRecord.attributes[attributeName]
          }
        }

        delete plainRecord.contributions

        delete plainRecord.company
        plainRecord.organizations = await record.getOrganizations({
          joinTableAttributes: [],
        })
        plainRecord.tags = await record.getTags({
          joinTableAttributes: [],
        })

        if (exportMode) {
          plainRecord.notes = await record.getNotes({
            joinTableAttributes: [],
          })
        }
        return plainRecord
      }),
    )
  }

  /**
   * Fill a record with the relations and files (if any)
   * @param record Record to get relations and files for
   * @param options IRepository options
   * @param returnPlain If true: return object, otherwise  return model
   * @returns The model/object with filled relations and files
   */
  static async _populateRelations(
    record,
    options: IRepositoryOptions,
    returnPlain = true,
    segmentId?: string,
  ) {
    if (!record) {
      return record
    }

    let output

    if (returnPlain) {
      output = record.get({ plain: true })
    } else {
      output = record
    }

    const transaction = SequelizeRepository.getTransaction(options)

    const activityAggregates = await MemberRepository.getActivityAggregates(
      output.id,
      options,
      segmentId,
    )

    output.activeOn = activityAggregates?.activeOn || []
    output.activityCount = activityAggregates?.activityCount || 0
    output.activityTypes = activityAggregates?.activityTypes || []
    output.activeDaysCount = activityAggregates?.activeDaysCount || 0
    output.averageSentiment = activityAggregates?.averageSentiment || 0

    output.lastActivity =
      (
        await record.getActivities({
          order: [['timestamp', 'DESC']],
          limit: 1,
          transaction,
        })
      )[0]?.get({ plain: true }) ?? null

    output.lastActive = output.lastActivity?.timestamp ?? null

    output.numberOfOpenSourceContributions = output.contributions?.length ?? 0

    output.tags = await record.getTags({
      transaction,
      order: [['createdAt', 'ASC']],
      joinTableAttributes: [],
    })

    output.organizations = await record.getOrganizations({
      transaction,
      order: [['createdAt', 'ASC']],
      joinTableAttributes: ['dateStart', 'dateEnd', 'title', 'source'],
      through: {
        where: {
          deletedAt: null,
        },
      },
    })
    MemberRepository.sortOrganizations(output.organizations)

    output.tasks = await record.getTasks({
      transaction,
      order: [['createdAt', 'ASC']],
      joinTableAttributes: [],
    })

    output.notes = await record.getNotes({
      transaction,
      joinTableAttributes: [],
    })

    output.noMerge = (
      await record.getNoMerge({
        transaction,
      })
    ).map((i) => i.id)

    output.toMerge = (
      await record.getToMerge({
        transaction,
      })
    ).map((i) => i.id)

    const memberIdentities = (await this.getIdentities([record.id], options)).get(record.id)

    output.username = {}

    for (const identity of memberIdentities) {
      if (output.username[identity.platform]) {
        output.username[identity.platform].push(identity.username)
      } else {
        output.username[identity.platform] = [identity.username]
      }
    }

    output.identities = Object.keys(output.username)

    output.affiliations = await this.getAffiliations(record.id, options)

    const manualSyncRemote = await new MemberSyncRemoteRepository(options).findMemberManualSync(
      record.id,
    )

    for (const syncRemote of manualSyncRemote) {
      if (output.attributes?.syncRemote) {
        output.attributes.syncRemote[syncRemote.platform] = syncRemote.status === SyncStatus.ACTIVE
      } else {
        output.attributes.syncRemote = {
          [syncRemote.platform]: syncRemote.status === SyncStatus.ACTIVE,
        }
      }
    }

    return output
  }

  static async updateMemberOrganizations(
    record,
    organizations,
    replace,
    options: IRepositoryOptions,
  ) {
    if (!organizations) {
      return
    }

    function iso(v) {
      return moment(v).toISOString()
    }

    if (replace) {
      const originalOrgs = await MemberRepository.fetchWorkExperiences(record.id, options)

      const toDelete = originalOrgs.filter(
        (originalOrg: any) =>
          !organizations.find(
            (newOrg) =>
              originalOrg.organizationId === newOrg.id &&
              originalOrg.title === (newOrg.title || null) &&
              iso(originalOrg.dateStart) === iso(newOrg.startDate || null) &&
              iso(originalOrg.dateEnd) === iso(newOrg.endDate || null),
          ),
      )

      for (const item of toDelete) {
        await MemberRepository.deleteWorkExperience((item as any).id, options)
      }
    }

    for (const item of organizations) {
      const org = typeof item === 'string' ? { id: item } : item
      await MemberRepository.createOrUpdateWorkExperience(
        {
          memberId: record.id,
          organizationId: org.id,
          title: org.title,
          dateStart: org.startDate,
          dateEnd: org.endDate,
          source: org.source,
        },
        options,
      )
      await OrganizationRepository.includeOrganizationToSegments(org.id, options)
    }
  }

  static async createOrUpdateWorkExperience(
    {
      memberId,
      organizationId,
      source,
      title = null,
      dateStart = null,
      dateEnd = null,
      updateAffiliation = true,
    },
    options: IRepositoryOptions,
  ) {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    if (dateStart) {
      // clean up organizations without dates if we're getting ones with dates
      await seq.query(
        `
          UPDATE "memberOrganizations"
          SET "deletedAt" = NOW()
          WHERE "memberId" = :memberId
          AND "organizationId" = :organizationId
          AND "dateStart" IS NULL
          AND "dateEnd" IS NULL
        `,
        {
          replacements: {
            memberId,
            organizationId,
          },
          type: QueryTypes.UPDATE,
          transaction,
        },
      )
    } else {
      const rows = await seq.query(
        `
          SELECT COUNT(*) AS count FROM "memberOrganizations"
          WHERE "memberId" = :memberId
          AND "organizationId" = :organizationId
          AND "dateStart" IS NOT NULL
          AND "deletedAt" IS NULL
        `,
        {
          replacements: {
            memberId,
            organizationId,
          },
          type: QueryTypes.SELECT,
          transaction,
        },
      )
      const row = rows[0] as any
      if (row.count > 0) {
        // if we're getting organization without dates, but there's already one with dates, don't insert
        return
      }
    }

    let conflictCondition = `("memberId", "organizationId", "dateStart", "dateEnd")`
    if (!dateEnd) {
      conflictCondition = `("memberId", "organizationId", "dateStart") WHERE "dateEnd" IS NULL`
    }
    if (!dateStart) {
      conflictCondition = `("memberId", "organizationId") WHERE "dateStart" IS NULL AND "dateEnd" IS NULL`
    }

    const onConflict =
      source === OrganizationSource.UI
        ? `ON CONFLICT ${conflictCondition} DO UPDATE SET "title" = :title, "dateStart" = :dateStart, "dateEnd" = :dateEnd, "deletedAt" = NULL, "source" = :source`
        : 'ON CONFLICT DO NOTHING'

    await seq.query(
      `
        INSERT INTO "memberOrganizations" ("memberId", "organizationId", "createdAt", "updatedAt", "title", "dateStart", "dateEnd", "source")
        VALUES (:memberId, :organizationId, NOW(), NOW(), :title, :dateStart, :dateEnd, :source)
        ${onConflict}
      `,
      {
        replacements: {
          memberId,
          organizationId,
          title: title || null,
          dateStart: dateStart || null,
          dateEnd: dateEnd || null,
          source: source || null,
        },
        type: QueryTypes.INSERT,
        transaction,
      },
    )

    if (updateAffiliation) {
      await MemberAffiliationRepository.update(memberId, options)
    }
  }

  static async deleteWorkExperience(id, options: IRepositoryOptions) {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    await seq.query(
      `
        UPDATE "memberOrganizations"
        SET "deletedAt" = NOW()
        WHERE "id" = :id
      `,
      {
        replacements: {
          id,
        },
        type: QueryTypes.UPDATE,
        transaction,
      },
    )
  }

  static async fetchWorkExperiences(memberId: string, options: IRepositoryOptions) {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    const query = `
      SELECT * FROM "memberOrganizations"
      WHERE "memberId" = :memberId
        AND "deletedAt" IS NULL
    `

    const records = await seq.query(query, {
      replacements: {
        memberId,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    return records
  }

  static async findWorkExperience(
    memberId: string,
    timestamp: string,
    options: IRepositoryOptions,
  ) {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    const query = `
      SELECT * FROM "memberOrganizations"
      WHERE "memberId" = :memberId
        AND (
          ("dateStart" <= :timestamp AND "dateEnd" >= :timestamp)
          OR ("dateStart" <= :timestamp AND "dateEnd" IS NULL)
        )
        AND "deletedAt" IS NULL
      ORDER BY "dateStart" DESC, id
      LIMIT 1
    `

    const records = await seq.query(query, {
      replacements: {
        memberId,
        timestamp,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    if (records.length === 0) {
      return null
    }

    return records[0]
  }

  static async findMostRecentOrganization(
    memberId: string,
    timestamp: string,
    options: IRepositoryOptions,
  ): Promise<any> {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    const query = `
      SELECT * FROM "memberOrganizations"
      WHERE "memberId" = :memberId
        AND "dateStart" IS NULL
        AND "dateEnd" IS NULL
        AND "createdAt" <= :timestamp
        AND "deletedAt" IS NULL
      ORDER BY "createdAt" DESC, id
      LIMIT 1
    `
    const records = await seq.query(query, {
      replacements: {
        memberId,
        timestamp,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    if (records.length === 0) {
      return null
    }

    return records[0]
  }

  static async findMostRecentOrganizationEver(
    memberId: string,
    options: IRepositoryOptions,
  ): Promise<any> {
    const seq = SequelizeRepository.getSequelize(options)
    const transaction = SequelizeRepository.getTransaction(options)

    const query = `
      SELECT * FROM "memberOrganizations"
      WHERE "memberId" = :memberId
        AND "dateStart" IS NULL
        AND "dateEnd" IS NULL
        AND "deletedAt" IS NULL
      ORDER BY "createdAt", id
      LIMIT 1
    `
    const records = await seq.query(query, {
      replacements: {
        memberId,
      },
      type: QueryTypes.SELECT,
      transaction,
    })

    if (records.length === 0) {
      return null
    }

    return records[0]
  }

  static sortOrganizations(organizations) {
    organizations.sort((a, b) => {
      a = a.dataValues ? a.get({ plain: true }) : a
      b = b.dataValues ? b.get({ plain: true }) : b
      const aStart = a.memberOrganizations?.dateStart
      const bStart = b.memberOrganizations?.dateStart
      const aEnd = a.memberOrganizations?.dateEnd
      const bEnd = b.memberOrganizations?.dateEnd

      // Sorting:
      // 1. Those without dateEnd, but with dateStart should be at the top, orderd by dateStart
      // 2. Those with dateEnd and dateStart should be in the middle, ordered by dateEnd
      // 3. Those without dateEnd and dateStart should be at the bottom, ordered by name
      if (!aEnd && aStart) {
        if (!bEnd && bStart) {
          return aStart > bStart ? -1 : 1
        }
        if (bEnd && bStart) {
          return -1
        }
        return -1
      }
      if (aEnd && aStart) {
        if (!bEnd && bStart) {
          return 1
        }
        if (bEnd && bStart) {
          return aEnd > bEnd ? -1 : 1
        }
        return -1
      }

      if (!bEnd && bStart) {
        return 1
      }
      if (bEnd && bStart) {
        return 1
      }
      return a.name > b.name ? 1 : -1
    })
  }

  static async getMemberIdsandCountForEnrich(
    { limit = 20, offset = 0, orderBy = 'joinedAt_DESC', countOnly = false },
    options: IRepositoryOptions,
  ) {
    const tenant = SequelizeRepository.getCurrentTenant(options)
    const segmentIds = SequelizeRepository.getSegmentIds(options)
    const seq = SequelizeRepository.getSequelize(options)

    const params: any = {
      tenantId: tenant.id,
      segmentIds,
      limit,
      offset,
    }

    let orderByString = ''
    const orderByParts = orderBy.split('_')
    const direction = orderByParts[1].toLowerCase()
    switch (orderByParts[0]) {
      case 'joinedAt':
        orderByString = 'm."joinedAt"'
        break
      case 'displayName':
        orderByString = 'm."displayName"'
        break
      case 'reach':
        orderByString = "(m.reach ->> 'total')::int"
        break
      case 'score':
        orderByString = 'm.score'
        break

      default:
        throw new Error(`Invalid order by: ${orderBy}!`)
    }
    orderByString = `${orderByString} ${direction}`

    const countQuery = `
    SELECT count(*) FROM (
      SELECT m.id
      FROM members m
      JOIN "memberSegments" ms ON ms."memberId" = m.id
      WHERE m."tenantId" = :tenantId
      AND ms."segmentId" IN (:segmentIds)
      AND (m."lastEnriched" IS NULL OR date_part('month', age(now(), m."lastEnriched")) >= 6)
      AND m."deletedAt" is NULL
    ) as count
    `

    const memberCount = await seq.query(countQuery, {
      replacements: params,
      type: QueryTypes.SELECT,
    })

    if (countOnly) {
      return {
        count: (memberCount[0] as any).count,
        ids: [],
      }
    }

    const members = await seq.query(
      `SELECT m.id FROM members m
      JOIN "memberSegments" ms ON ms."memberId" = m.id
      WHERE m."tenantId" = :tenantId and ms."segmentId" in (:segmentIds) 
      AND (m."lastEnriched" IS NULL OR date_part('month', age(now(), m."lastEnriched")) >= 6)
      AND m."deletedAt" is NULL
      ORDER BY ${orderByString} 
      LIMIT :limit OFFSET :offset`,
      {
        replacements: params,
        type: QueryTypes.SELECT,
      },
    )

    return {
      count: (memberCount[0] as any).count,
      ids: members.map((i: any) => i.id),
    }
  }

  static async moveNotesBetweenMembers(
    fromMemberId: string,
    toMemberId: string,
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const params: any = {
      fromMemberId,
      toMemberId,
    }

    const deleteQuery = `
      delete from "memberNotes" using "memberNotes" as mn2
      where "memberNotes"."memberId" = :fromMemberId 
      and "memberNotes"."noteId" = mn2."noteId"
      and mn2."memberId" = :toMemberId;
    `

    await seq.query(deleteQuery, {
      replacements: params,
      type: QueryTypes.DELETE,
      transaction,
    })

    const updateQuery = `
      update "memberNotes" set "memberId" = :toMemberId where "memberId" = :fromMemberId;
    `

    await seq.query(updateQuery, {
      replacements: params,
      type: QueryTypes.UPDATE,
      transaction,
    })
  }

  static async moveTasksBetweenMembers(
    fromMemberId: string,
    toMemberId: string,
    options: IRepositoryOptions,
  ): Promise<void> {
    const transaction = SequelizeRepository.getTransaction(options)

    const seq = SequelizeRepository.getSequelize(options)

    const params: any = {
      fromMemberId,
      toMemberId,
    }

    const deleteQuery = `
      delete from "memberTasks" using "memberTasks" as mt2
      where "memberTasks"."memberId" = :fromMemberId 
      and "memberTasks"."taskId" = mt2."taskId"
      and mt2."memberId" = :toMemberId;
    `

    await seq.query(deleteQuery, {
      replacements: params,
      type: QueryTypes.DELETE,
      transaction,
    })

    const updateQuery = `
      update "memberTasks" set "memberId" = :toMemberId where "memberId" = :fromMemberId;
    `

    await seq.query(updateQuery, {
      replacements: params,
      type: QueryTypes.UPDATE,
      transaction,
    })
  }
}

export default MemberRepository
